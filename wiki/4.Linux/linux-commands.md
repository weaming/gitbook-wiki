![](http://i.imgur.com/BcLU77S.jpg)
总结一些linux下常用的命令用法
==

一些概念
--
- `UID`：用户ID（英语：user identifier，一般缩写为User ID或UID），全称`用户标识符`，在类UNIX系统中是内核用来辨识用户的一个无符号整型数值，亦是UNIX文件系统与进程的必要组成部分之一。[参考](https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7ID)
- `GID`=group id
- `~`代表了你的`$HOME`目录。
- `.`代表当前目录
- `..`代表上级目录
- `\`代表根目录
- `*`通配符匹配n个字符

ls
--
- ls是英文`list segment`的缩写，用于列出文件，是Unix系统中使用非常频繁的命令。
- 当不加参数运行时，ls列出当前目录下的所有文件和目录名。这通常让人很难区分文件的类型、大小、权限等属性。
- 如果以目录名作为参数，则会列出该目录下的文件。
- 用户也可以指定多个文件和目录作为参数，则会列出所有指定的文件和目录中的文件名。
- 以 "`.`"（圆点）开头的目录在一般情况下不会被列出。用户可以加 `-a` 选项查看所有文件。

参数选项：

- `-l`（long）长格式，显示文件类型、权限、硬链接的数目、文件拥有者、文件所在的组、大小、日期和文件名。
- `-F` 在不同类型的文件的文件名结尾追加一个字符以示区别。可执行文件后加"`*`"，目录后加"`/`"，渠道文件后加"`|`"，套接字文件后加"`=`"，普通文件没有后缀。
- `-a`（all）显示所有文件，包括以`.`开头的文件名（默认不显示）。
- `-R`（recursive）迭代显示目录下所有的子目录。`ls -R`会显示文件系统中的所有文件。
- `-d`（directory）显示目录本身的信息，而不是列出目录下的文件。

在某些环境下，使用参数"`--color`"（GNU版）或者"`-G`"（FreeBSD版）后，ls会根据文件类型输出不同色彩的格式。GNU版的ls根据文件的类型、扩展名和使用权限来决定颜色，而FreeBSD版的ls仅仅检查文件类型和使用权限。
<!--more-->

chmod
--
chmod是一条在Unix系统中用于控制用户对文件的权限的命令（change mode单词前缀的组合）和函数。只有**文件所有者**和**超级用户**可以修改文件或目录的权限。可以使用`绝对模式`，`符号模式`指定文件的权限。

$ chmod [options] mode[,mode] file1 [file2 ...]

### 八进制语法 ###
chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件**所有者**（User）的读、写、执行，**用户组**（Group）的读、写、执行以及**其它用户**（Other）的读、写、执行。

- r 4
- w 2
- x 1
- - 0

例如

- 所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如rwx ，也就是4+2+1 ，应该是7。
- 用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如rw- ，也就是4+2+0 ，应该是6。
- 其它用户的权限数字表达：其它用户权限位的数字相加的总和。如r-x ，也就是4+0+1 ，应该是5。

### 符号模式 ###
符号模式可以设置多个项目：**who**(用户类型），**operator**(操作符）和**permission**(权限）,每个项目的设置可以用逗号隔开。

命令chmod将修改**who**指定的用户类型对文件的**访问权限**，用户类型由一个或者多个字母在who的位置来说明

who | 用户类型 | 说明
---|---|---
u|  user|   文件所有者
g|  group|  文件所有者所在组
o|  others| 所有其他用户
a|  all|    所用用户, 相当于 ugo

operator的符号模式表:

Operator |  说明
---|---
+   |为指定的用户类型增加权限
-   |去除指定用户类型的权限
=   |设置指定用户权限的设置，即将用户类型的所有权限重新设置

permission的符号模式表:

模式|名字|说明
---|---|---
r   |读| 设置为可读权限
w   |写| 设置为可写权限
x   |执行权限|  设置为可执行权限
X   |特殊执行权限|    只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行
s   |setuid/gid|    当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限
t   |粘贴位|   设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位

例子：
chmod u+x filename 在这里，u的意思是user指用户本人；+的意思是增加权限；x是指可执行权限

chown
--

    chown [选项]... [所有者][:[组]] 文件...

chown 是一条在Unix系统中用于设置文件所有者和文件关联组的命令。 需要超级用户的权限才能执行此命令。只有**超级用户**和**属于组的文件所有者**才能变更文件关联组。非超级用户如需要设置关联组可能需要使用`chgrp`命令。

必要参数:

- -c 显示更改的部分的信息
- -f 忽略错误信息
- -h 修复符号链接
- -R 处理指定目录以及其子目录下的所有文件
- -v 显示详细的处理信息
- -deference 作用于符号链接的指向，而不是链接文件本身

选择参数:

- --reference=<目录或文件> 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组
- --from=<当前用户：当前群组> 只有当前用户和群组跟指定的用户和群组相同时才进行改变
- --help 显示帮助信息
- --version 显示版本信息


chgrp
--
chgrp是一条在Unix系统中用于设置文件所归属的组的命令。与chown命令不同，chgrp允许普通用户改变文件所属的组，只要该用户是该组的一员。

    chgrp 组名 目标1 [目标2 ...]

    "组名"是文件即将关联的组。"组名"既可以使用字符名称也可以使用ID。
    "目标1 [目标2 ...]"是需要改变组的文件或目录的列表。

chattr
--
有时候你发现用root权限都不能修改某个文件，大部分原因是曾经用chattr命令锁定该文件了。

chattr命令的作用很大，其中一些功能是由Linux内核版本来支持的，不过现在生产绝大部分跑的linux系统都是2.6以上内核了。通过chattr命令修改属性能够提高系统的安全性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录。

lsattr命令是显示chattr命令设置的文件属性。如果要查看被chattr改变的文件属性，需用lsattr命令。

**模式说明**：

A：文件或目录的 atime (access time)不可被修改(modified), 可以有效预防例如手提电脑磁盘I/O错误的发生。
**a：即append，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件安全，只有root才能设定这个属性。**
c：即compresse，设定文件是否经压缩后再存储。读取时需要经过自动解压操作。
d：即no dump，设定文件不能成为dump程序的备份目标。
**i：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。i参数对于文件 系统的安全设置有很大帮助。**
j：即journal，设定此参数使得当通过mount参数：data=ordered 或者 data=writeback 挂 载的文件系统，文件在写入时会先被记录(在journal中)。如果filesystem被设定参数为 data=journal，则该参数自动失效。
S：硬盘I/O同步选项，功能类似sync。
s：保密性地删除文件或目录，即硬盘空间被全部收回。
u：与s相反，当设定为u时，数据内容其实还存在磁盘中，可以用于undeletion。
各参数选项中常用到的是a和i。a选项强制只可添加不可删除，多用于日志系统的安全设定。而i是更为严格的安全设定，只有superuser (root) 或具有CAP_LINUX_IMMUTABLE处理能力（标识）的进程能够施加该选项。

**参数说明**：

- -R：递归处理，将指定目录下的所有文件及子目录一并处理。
- -v<版本编号>：设置文件或目录版本。
- -V：显示指令执行过程。
- +<属性>：在原有参数设定基础上，追加参数
- -<属性>：在原有参数设定基础上，移除参数。
- =<属性>：更新为指定参数设定。

rm
--
rm，是一个基本的UNIX命令，其名称源自英文单词**remove**的缩写，用于删除文件系统中的文件、目录、设备文件、符号链接等对象。

准确地说，rm移除的指向特定对象的引用。在文件系统中，这些特定的对象可能有多个引用（例如，两个不同的文件名可能指向相同的文件）, 只有在一个对象不再有任何引用，并且没有任何程序还拥有这个文件的有效句柄的时候，这个文件才会被删除。

rm命令一般来说并不摧毁文件数据，因为其目的仅仅在于解除引用。即便文件已经解除所有的引用，在文件系统中，被释放的空间里可能还会有被删除文件的残留数据。在一些情况下这会带来安全问题，因此有时加强版的命令会在文件的最后一个链接断开之后抹除被删除文件的数据。此外，一些程序（例如 shred）可以提供数据抹除能力。

- 一般而言，rm不产生输出信息，其只在错误发生的时候才报告错误信息。 如果加上参数`-v`，则可以获得详细的文件移除的动作信息。
- 有时用户担心意外删除文件，特别是在使用通配符删除文件的时候。 这些情况下可以使用`-i`参数，使rm在执行每个删除动作之前都提示用户确认。

rm 一般在UNIX及其衍生操作系统中出现，而这些**系统不提供已被删除文件的恢复机制**（例如回收站）[1因此用户常对rm命令进行一些封装以避免意外删除文件。

**参数**：

- `-r` ： 递归("recursive")，删除目录，在删除这一目录前会事先删除目录中的内容（避免删除了目录而使目录中的文件无处存放的问题）
- `-i` ： 交互("interactive")，为每一个删除操作询问一次删除确认。
- `-f` ： 强制("force")，忽视不存在的文件，无视任何的确认提示。但是若目录写保护，这一命令无法移除该目录中的文件。

rm命令常常被“rm -i”命令覆盖，这样可以防止意外的文件删除操作。 如果用户还是想不通过确认而删除大量的文件，他们可以手动为命令追加“`-f`”参数，取消"-i"参数的效果（这是因为加上“-f”参数后，命令变为了“rm -i -f”，而**后指定的参数有更高的优先级**）。

**权限**：

一般而言，在大部分文件系统中，删除文件需要文件**所在目录**的**写权限**（首先为了进入该目录，还需要该目录的**执行权限**）。（注意：这里需要的是目录的**执行权限**，至于**文件自身**是否有**写权限**与删除操作成功与否无关。然而，除非使用`-f`参数，如果想要删除写保护文件，GNU rm将询问用户确认。）

使用`rm -r`删除目录时，必须先递归删除这一目录中所有的内容。这就要求用户必须获得对于目录（及其子目录）的读、写、执行权限（若目录非空）。需要读目录的权限是因为删除目录中的文件，需要先列出目录中的内容。

若在将要删除的目录中的某个文件设置了sticky bit，那么这个文件只能由其所有者删除。

du
--
`disk usage`的缩写（磁盘使用情况）是一个估计某个特定目录或文件在文件系统上磁盘使用情况的标准Unix程序。

du可以带一个参数，即指定一个路径来工作；如果没有指定，则使用当前目录

有以下这些选项：

- -a或-all：显示目录中个别文件的大小。
- -b或-bytes：显示目录或文件大小时，以byte为单位。
- -c或--total：除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。
- -k或--kilobytes：以KB(1024bytes)为单位输出。
- -m或--megabytes：以MB为单位输出。
- -s或--summarize：仅显示总计，只列出最后加总的值。
- -h或--human-readable：以K，M，G为单位，提高信息的可读性。以1024为换算单位。
- -x或--one-file-xystem：以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。
- -L<符号链接>或--dereference<符号链接>：显示选项中所指定符号链接的源文件大小。
- -S或--separate-dirs：显示个别目录的大小时，并不含其子目录的大小。
- -X<文件>或--exclude-from=<文件>：在<文件>指定目录或文件。
- --exclude=<目录或文件>：略过指定的目录或文件。
- -D或--dereference-args：显示指定符号链接的源文件大小。
- -H或--si：与-h参数相同，但是K，M，G是以1000为换算单位。
- -l或--count-links：重复计算硬件链接的文件。

ln
--
ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。

当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。

    ln [参数][源文件或目录][目标文件或目录]

软链接：
1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式
2.软链接可以 跨文件系统 ，硬链接不可以
3.软链接可以对一个不存在的文件名进行链接
4.软链接可以对目录进行链接

硬链接:
1.硬链接，以文件副本的形式存在。但不占用实际空间。
2.不允许给目录创建硬链接
3.硬链接只有在同一个文件系统中才能创建

注意：
第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；
第二，ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。
第三，最后的目的地必须是一个已经存在的目录

**必要参数**:

- -b 删除，覆盖以前建立的链接
- -d 允许超级用户制作目录的硬链接
- -f 强制执行
- -i 交互模式，文件存在则提示用户是否覆盖
- -n 把符号链接视为一般目录
- -s 软链接(符号链接)
- -v 显示详细的处理过程

**选择参数**:

- -S：“-S<字尾备份字符串> ”或 “--suffix=<字尾备份字符串>”
- -V：“-V<备份方式>”或“--version-control=<备份方式>”
- --help：显示帮助信息
- --version：显示版本信息

cat
--
cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。

    cat [选项] [文件]...

主要三大功能：

1. 一次显示整个文件:cat filename
2. 从键盘创建一个文件:cat > filename 只能创建新文件,不能编辑已有文件.
3. 将几个文件合并为一个文件:cat file1 file2 > file

选项|等价选项|含义
---|---|---
-A|--show-all           |等价于 -vET
-b| --number-nonblank    |对非空输出行编号
-e|                      |等价于 -vE
-E| --show-ends          |在每行结束处显示 $
-n| --number     |对输出的所有行编号，由1开始对所有输出的行数编号
-s| --squeeze-blank  |有连续两行以上的空白行，就代换为一行的空白行
-t|                      |与 -vT 等价
-T| --show-tabs          |将跳格字符显示为 ^I
-u|                      |(被忽略)
-v| --show-nonprinting   |使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外

mount
--
mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。

此命令的最常用于挂载cdrom，使我们可以访问cdrom中的数据，因为你将光盘插入cdrom中，Linux并不会自动挂载，必须使用mount命令来手动完成挂载。

系统管理者或/etc/fstab中允许的使用者才能有权使用mount。

    mount(选项)(参数)

**选项**：

- -V：显示程序版本；
- -l：显示已加载的文件系统列表；
- -h：显示帮助信息并退出；
- -v：冗长模式，输出指令执行的详细信息；
- -n：加载没有写入文件“/etc/mtab”中的文件系统；
- -r：将文件系统加载为只读模式；
- -a：加载文件“/etc/fstab”中描述的所有文件系统。

**参数**：

1. 设备文件名：指定要加载的文件系统对应的设备名；
2. 加载点：指定加载点目录。

mkdir
--
创建文件夹

**选项**：

- -Z：设置安全上下文，当使用SELinux时有效；
- -m<目标属性>或--mode<目标属性>：建立目录的同时设置目录的权限；
- -p或--parents：若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；
- --version：显示版本信息。

**参数**：
目录：指定要创建的目录列表，多个目录之间用空格隔开。

tar
--
tar命令（[参考链接](http://man.linuxde.net/tar)）可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（**备份文件**），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。

利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。

要弄清两个概念：打包和压缩。**打包**是指将一大堆文件或目录变成一个总的文件；**压缩**则是将一个大的文件通过一些压缩算法变成一个小文件

为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。

**选项**：

- -A或--catenate：新增文件到以存在的备份文件；
- -B：设置区块大小；
- **-c或--create：建立新的备份文件；**
- **-C <目录>：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。**
- -d：记录文件的差别；
- **-x或--extract或--get：从备份文件中还原文件；**
- **-t或--list：列出备份文件的内容；**
- **-z或--gzip或--ungzip：通过gzip指令处理备份文件；**
- -Z或--compress或--uncompress：通过compress指令处理备份文件；
- **-f<备份文件>或--file=<备份文件>：指定备份文件；**
- **-v或--verbose：显示指令执行过程；**
- -r：添加文件到已经压缩的文件；
- -u：添加改变了和现有的文件到已经存在的压缩文件；
- **-j：支持bzip2解压文件；**
- -l：文件系统边界设置；
- -k：保留原有文件不覆盖；
- -m：保留文件不被覆盖；
- -w：确认压缩文件的正确性；
- **-p或--same-permissions：用原来的文件权限还原文件；**
- -P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；
- -N <日期格式> 或 --newer=<日期时间>：只将较指定日期更新的文件保存到备份文件里；
- --exclude=<范本样式>：排除符合范本样式的文件。

在选项`f`之后的文件档名是自己取的，我们习惯上都用 `.tar` 来作为辨识。 如果加`z`选项，则以`.tar.gz`或`.tgz`来代表`gzip压缩`过的tar包；如果加`j`选项，则以`.tar.bz2`来作为tar包名。

**常用命令**

    解压
    tar -zxvf filename.tar.gz
    tar -jxvf filename.tar.bz2[ -C 解压路径]

    查询
    tar -ztvf filename.tar.gz

    压缩
    tar -zcvf filename.tar.gz 欲压缩文件或目录

gzip
--
gzip命令用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“`.gz`”扩展名。

gzip是在Linux系统中经常使用的一个对文件进行**压缩**和**解压缩**的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和`tar`命令一起构成Linux操作系统中比较流行的压缩文件格式。

据统计，gzip命令对文本文件**有60%～70%的压缩率**。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。

**选项**：

- -a或——ascii：使用ASCII文字模式；
- **-d或--decompress或----uncompress：解开压缩文件；**
- **-f或——force：强行压缩文件。**不理会文件名称或硬连接是否存在以及该文件是否为符号连接；
- -h或——help：在线帮助；
- **-l或——list：列出压缩文件的相关信息；**
- -L或——license：显示版本与版权信息；
- -n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；
- -N或——name：压缩文件时，保存原来的文件名称及时间戳记；
- -q或——quiet：不显示警告信息；
- **-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；**
- -S或<压缩字尾字符串>或----suffix<压缩字尾字符串>：更改压缩字尾字符串；
- -t或——test：测试压缩文件是否正确无误；
- **-v或——verbose：显示指令执行过程；**
- -V或——version：显示版本信息；
- -<压缩效率>：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；
- --best：此参数的效果和指定“-9”参数相同；
- --fast：此参数的效果和指定“-1”参数相同。

find
--
搜索文件命令 | 参考[文章](http://www.cnblogs.com/peida/archive/2012/11/16/2773289.html)
### name选项：按名称 ###
文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。

可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。

想要在/etc目录中查找文件名以host开头的文件，可以用：

    find /etc -name "host*" -print

### perm选项：按权限 ###
按照文件权限模式用`-perm`选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法。

如在**当前目录**下查找文件权限位为**755**的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用：

    find . -perm 755 -print

还有一种表达方法：在八进制数字前面要加一个横杠-，表示都匹配，如-007就相当于777，-005相当于555

### prune选项：忽略某个目录 ###

### user和nouser选项：按文件用户 ###
- -user后跟用户名称
- -nouser后留空，不必给出用户名

### group和nogroup选项：按文件用户组 ###
同上

### mtime,atime或ctime选项：按照更改时间 ###
- 用减号`-`来限定更改时间在距今n日以内的文件
- 用加号`+`来限定更改时间在距今n日以前的文件。

### newer选项：相比较新 ###
- 查找更改时间比某个文件新但比另一个文件旧的所有文件
- 查找更改时间比文件log2012.log新但比文件log2017.log旧的文件

        find -newer log2012.log ! -newer log2017.log

### type选项 ###

    实例1：在/etc目录下查找所有的目录
    命令：
    find /etc -type d -print
    实例2：在当前目录下查找除目录以外的所有类型的文件
    命令：
    find . ! -type d -print
    实例3：在/etc目录下查找所有的符号链接文件
    命令：
    find /etc -type l -print

### size选项 ###
可以按照文件长度来查找文件，这里所指的文件长度既可以用`块（block）`来计量，也可以用`字节`来计量。以字节计量文件长度的表达形式为`Nc`,`N`表示数字；以块计量文件长度**只用数字**表示即可。

    find . -size +1000000c -print
    find /home/apache -size 100c -print
    find . -size +10 -print

### depth选项 ###
在使用find命令时，可能希望先匹配所有的文件，再在子目录中查找。使用depth选项就可以使find命令这样做。

这样做的一个原因就是，当在使用find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。

    find / -name "CON.FILE" -depth -print
    #首先匹配所有的文件然后再进入子目录中查找

### mount选项 ###
在当前的文件系统中查找文件（不进入其他文件系统）

    find . -name "*.sh" -mount -print

字节流
==
>如果以bit为单位处理字符的话，机器会更容易读懂和传输，效率会更高。但为什么Linux依然以字节为单位进行处理呢？原因在于，相对于以bit为单位处理数据，以byte为单位可以更容易将数据转化为字符。相对于枯燥的0和1，字符更容易被人读懂 (human readable)。然而，并不是所有的数据都是设计来让人读懂的，比如可执行文件包含的各种字符对于人来说并没有什么意义 (因为可执行文件是为了让机器读懂的)。但Linux依然以字节为单位处理所有文件，这是为了让所有文件能够**共用一套接口** (virtual file system)，从而减少Linux设计的复杂度。

- 当Linux执行一个程序的时候，会自动打开三个流，标准输入(standard input)，标准输出(standard output)，标准错误(standard error)。比如说你打开命令行的时候，默认情况下，命令行的标准输入连接到键盘，标准输出和标准错误都连接到屏幕。
- 重定向：
- `>` - 重新定向标准输出
- `>>` - 重新定向标准输入
- `>&` - 同时重新定向标准输出和标准错误
- `2>` - 只重新定向标准错误

管道（pipe）
==
> 管道可以将一个命令的输出导向另一个命令的输入，从而让两个(或者更多命令)像流水线一样连续工作，不断地处理文本流。在命令行中，我们用`|`表示管道：

```
$cat < a.txt | wc
```

wc命令代表word count，用于统计文本中的行、词以及字符的总数。a.txt中的文本先流到cat，然后从cat的标准输出流到wc的标准输入，从而让wc知道自己要处理的是a.txt这个字符串。

信号
==
- SIGINT - 当键盘按下CTRL+C从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是中断 (INTERRUPT) 该进程。
- SIGQUIT - 当键盘按下CTRL+\从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是退出 (QUIT) 该进程。
- SIGTSTP - 当键盘按下CTRL+Z从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是暂停 (STOP) 该进程。
- SIGCONT - 用于通知暂停的进程继续。
- SIGALRM - 起到定时器的作用，通常是程序在一定的时间之后才生成该信号。

其他命令
--
- pstree：显示整个进程树
- man 7 signal：查阅信号
- ctrl + l：清屏
- ctrl + u：清行
- ctrl + r：命令历史搜索

一个典型的Linux分区(partition)包含有下面各个部分
--
![](http://images.cnitblog.com/blog/413416/201402/250221581092754.png)

- 第一个部分是启动区(Boot block)，它主要是为计算机开机服务的。Linux开机启动后，会首先载入MBR，随后MBR从某个硬盘的启动区加载程序。该程序负责进一步的操作系统的加载和启动。为了方便管理，即使某个分区中没有安装操作系统，Linux也会在该分区预留启动区。
- 启动区之后的是超级区(Super block)。它存储有文件系统的相关信息，包括文件系统的类型，inode的数目，数据块的数目。
- 随后是多个inodes，它们是实现文件存储的关键。
 - 在Linux系统中，一个文件可以分成几个数据块存储，就好像是分散在各地的龙珠一样。为了顺利的收集齐龙珠，我们需要一个“雷达”的指引：该文件对应的inode。每个文件对应一个inode。这个inode中包含多个指针，指向属于该文件各个数据块。当操作系统需要读取文件时，只需要对应inode的"地图"，收集起分散的数据块，就可以收获我们的文件了。
- 最后一部分，就是真正储存数据的数据块们(data blocks)了。

inode简介
--
> 文件是文件系统对数据的分割单元。文件系统用目录来组织文件，赋予文件以上下分级的结构。在硬盘上实现这一分级结构的关键，是使用inode来虚拟普通文件和目录文件对象。

在Linux文件管理中，我们知道，一个文件除了自身的数据之外，还有一个附属信息，即文件的元数据(metadata)。这个元数据用于记录文件的许多信息，比如文件大小，拥有人，所属的组，修改日期等等。元数据并不包含在文件的数据中，而是由操作系统维护的。事实上，这个所谓的元数据就包含在inode中。我们可以用`$ls -l filename`来查看这些元数据。正如我们上面看到的，inode所占据的区域与数据块的区域不同。每个inode有一个唯一的整数编号(inode number)表示。

inode并不是组织文件的唯一方式。最简单的组织文件的方法，是把文件依次顺序的放入存储设备，DVD就采取了类似的方式。但如果有删除操作，删除造成的空余空间夹杂在正常文件之间，很难利用和管理。

复杂的方式可以使用链表，每个数据块都有一个指针，指向属于同一文件的下一个数据块。这样的好处是可以利用零散的空余空间，坏处是对文件的操作必须按照线性方式进行。如果想随机存取，那么必须遍历链表，直到目标位置。由于这一遍历不是在内存进行，所以速度很慢。

FAT系统是将上面链表的指针取出，放入到内存的一个数组中。这样，FAT可以根据内存的索引，迅速的找到一个文件。这样做的主要问题是，索引数组的大小与数据块的总数相同。因此，存储设备很大的话，这个索引数组会比较大。

inode既可以充分利用空间，在内存占据空间不与存储设备相关，解决了上面的问题。但inode也有自己的问题。每个inode能够存储的数据块指针总数是固定的。如果一个文件需要的数据块超过这一总数，inode需要额外的空间来存储多出来的指针。

参考链接
--
- [peida博客](http://www.cnblogs.com/peida/)
- Linux[命令大全](http://man.linuxde.net/)
- vamei的 [Linux常用命令](http://www.cnblogs.com/vamei/archive/2013/03/03/2871198.html)